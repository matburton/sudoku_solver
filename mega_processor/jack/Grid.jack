
class Grid {

    function int gridWordSize() {
    
        // 81 squares, 2 words each and 1 word grid cache
        //
        return 163;
    }

    function Array initialise(Array grid) {
           
        var int index;
       
        let index = 0;
        
        while (index < 162) {
        
            let grid[index] = 511; // All 9 values are possible

            let grid[index + 1] = 2304; // 9 possibilities and no value

            let index = index + 2;
        }
        
        let grid[162] = 81; // All squares incomplete, grid possible
        
        return grid;
    }

    function void cloneToGrid(Array source, Array target) {

        var int index;
        
        let index = 0;
        
        while (index < 163) {

            let target[index] = source[index];

            let index = index + 1;
        }
    
        return;
    }

    // Cannot be used to stop isPossible returning false
    //
    // Assumes the square has the given value as a possibility
    // and is incomplete, i.e. has at least one other possibility
    //
    function void setSquareValue(Array grid, int value, int x, int y) {
    
        var Array square;
        
        let square = y * 9 + x * 2 + grid;

        let square[0] = Grid.two_to_the(value - 1); // No shifting available
        
        let square[1] = value | 256;
        
        let grid[162] = grid[162] - 1;
    
        return;
    }
    
    function boolean squareHasPossibility(Array grid, int value, int x, int y) {
    
        return grid[y * 9 + x * 2] & Grid.two_to_the(value - 1) > 0;
    }

    // Returns the new square value if the square was previously incomplete,
    // i.e. had multiple possibilities, but now only has one. Otherwise
    // returns zero, e.g. if the square is still incomplete or did not have
    // the given value as a possibility
    //
    function int removeSquarePossibility(Array grid, int value, int x, int y) { 
    
        var Array square;
        
        var int variable;
        
        let square = y * 9 + x * 2 + grid;
        
        let variable = Grid.two_to_the(value - 1);

        if (square[0] & variable = 0) {
        
            return 0;
        }
        
        let square[0] = square[0] & ~variable;
        
        let variable = square[1] / 256 - 1; // No shifting available
        
        if (0 = variable) {

            let square[1] = 0;

            let grid[162] = grid[162] + 257;
            
            return 0;
        }
        
        if (1 = variable) {
        
            let variable = Grid.calculateValue(square[0]);
            
            let square[1] = variable + 256;
        
            let grid[162] = grid[162] - 1;
            
            return variable;
        }
        
        let square[1] = variable * 256;
        
        return 0;
    }

    function int getPossibilityCount(Array grid, int x, int y) {
    
        return grid[y * 9 + x * 2 + 1] / 256; // No shifting available
    }
    
    // Returns 0 if the square has multiple possibilities or no possibilities
    //
    function int getSquareValue(Array grid, int x, int y) {
  
        return grid[y * 9 + x * 2 + 1] & 15;
    }
    
    // Once this returns false it will always return false
    // Using setSquareValue cannot make this return true again
    //
    function boolean isPossible(Array grid) {
    
        return grid[162] < 82;
    }

    function boolean isComplete(Array grid) {
    
        return 0 = grid[162];
    }
    
    function boolean mustBeValue(Array grid, int x, int y, int value) {
    
        return false; // TODO
    }
    
    // Assumes there is one one possibility 
    //
    function int calculateValue(int possibilities) {
    
        var int value;
    
        let value = 0;
        
        while (possibilities > Grid.two_to_the(value)) {
        
            let value = value + 1;
        }
    
        return value + 1;
    }
    
    function int two_to_the(int value) {
    
        var int output;
        
        let output = 1;
        
        while (value > 0) {
        
            let output = output * 2;
            
            let value = value - 1;
        }
        
        return output;
    }
}